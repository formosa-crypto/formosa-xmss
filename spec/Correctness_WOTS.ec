pragma Goals : printall.

require import AllCore List RealExp IntDiv.
require Subtype. 

from Jasmin require import JModel.

require import Notation Parameters Address Primitives Wots.

import NBytes.
import Array8.

require import XMSS_IMPL.

(*
    We first prove that the equivalence between the extracted EC and the preprocessed EC
    We then prove that the preprocessed EC is equivalent to the specification (so the extracted EC is also equivalent to the spec)
*)

require import Array2 Array3 Array32 Array67.

abbrev (<=) (a b : W64.t) = a \ule b.

(* Adding one to a non negative number yields a non negative number *)
lemma add_zero (x : W64.t) : 
    W64.zero <= x =>
       W64.zero <= x + W64.one.
proof.
move => H.
admit.
qed.

module BaseWGeneric = {
  proc __base_w (output : W32.t list, input : W8.t list) : W32.t list = {

    var in_0:W64.t;
    var out:W64.t;
    var bits:W64.t;
    var consumed:W64.t;
    var total:W8.t;
    var total_32:W32.t;
    var _of_:bool;
    var _cf_:bool;
    var _sf_:bool;
    var _zf_:bool;
    var  _0:bool;

    var inlen : W64.t <- W64.of_int (size input);
    var outlen : W64.t <- W64.of_int (size output);

    in_0 <- W64.zero;
    out <- W64.zero;
    bits <- W64.zero;
    consumed <-W64.zero;

    while ((consumed \ult outlen)) {
      if (bits = W64.zero) {
        total <- input.[(W64.to_uint in_0)];
        in_0 <- (in_0 + (W64.of_int 1));
        bits <- (bits + (W64.of_int 8));
      }
      
      bits <- (bits - (W64.of_int 4));
      total_32 <- (zeroextu32 total);
      (_of_, _cf_, _sf_,  _0, _zf_, total_32) <- SHR_32 total_32 (truncateu8 bits);
      total_32 <- (total_32 `&` (W32.of_int (16 - 1)));
      output <- put output (W64.to_uint out) total_32; (* output.[(W64.to_uint out)] <- total_32; *)
      out <- (out + (W64.of_int 1));
      consumed <- (consumed + (W64.of_int 1));
    }

    return (output);
  }
}.

lemma base_w_generic_1 (input : W8.t Array2.t) :
    let _input  : W8.t list = mkseq (fun i => input.[i]) 2 in
    equiv[M(Syscall).__base_w_3_2 ~ BaseWGeneric.__base_w :
       arg{1}.`2 = input /\
       arg{2}.`2 = _input ==>
    forall (i : int), 0 <= i < 3 => res{1}.[i] = nth witness res{2} i].
proof.
(* move => *. *)
(* proc. *)
(* auto => /> *. *)
(* smt(). *)
(* while( *)
(*   W64.zero <= consumed{1} <= W64.of_int 3 /\ *)
(*   consumed{1} = consumed{2} /\ *)
(*   outlen{2} = W64.of_int 3 /\ *)
(*   inlen{2} = W64.of_int 2 *)
(* ). *)
(* auto => /> *. *)
(* split. *)
(* smt(add_zero). *)
(* move => H. admit. (* FIXME: consumed{2} + 1 <= 3 : Cant prove this (?) *) *)
(* sp. auto => />. *)
(* move => *. *)
(* rewrite negb_and. *)
(* left. *)
(* (* input{&1} != input : Cant prove this *) *)
admit.
qed.

lemma base_w_generic_2 (output : W32.t Array67.t, input : W8.t Array32.t):
    let _output = mkseq (fun i => output.[i]) 67 in
    let _input  = mkseq (fun i => input.[i]) 32 in 
    size _output = 67 /\ size _input = 32 =>
    equiv[M(Syscall).__base_w_67_32 ~ BaseWGeneric.__base_w :
       arg{1} = (output, input) /\
       arg{2} = (_output, _input) ==> 
      mkseq (fun i => res{1}.[i]) 67 = res{2}].
proof.
move => *.
progress.
proc.
auto => /> *.
while (
  consumed{1} = consumed{2} /\
  inlen{2} = W64.of_int 32 /\ outlen{2} = W64.of_int 67 /\
  (forall (k : int), 0 < k < W64.to_uint inlen{2} => input{1}.[k] = input{2}.[k]) /\
  (forall (k : int), 0 < k < W64.to_uint outlen{2} => output{1}.[k] = output{2}.[k])
).
- auto. (* This solves the first subgoal generated by while *)
- auto => /> *. progress. (* progress generates 4 subgoals *)
    - smt().
    - smt().
    - smt. (* FIXME: How to use assumption H when I call smt? smt() fails but smt(H) doesnt work *)
    - admit. (* FIXME: *)
qed.

(*********************************************************************************************)

(* This lemma states that the the generic version of base_w (which is/will be proved above that is equivalent to the one extracted from the Jasmin impl) is correct with respect to the specification *)
lemma base_w_impl_spec (input : byte list, outlen : int) :
    let t : W32.t list = nseq outlen W32.zero in
    size t = outlen => 
    equiv[BaseW.base_w ~ BaseWGeneric.__base_w :
      arg{1} = (input, outlen) /\
      arg{2} = (t, input) ==> 
    map W32.of_int res{1} = res{2}].
proof.
move => *.
proc.
auto => /> *.
while(
  input{1} = input{2} /\ total{1} = total{2}
).
admit. (* TODO: *)
qed.
