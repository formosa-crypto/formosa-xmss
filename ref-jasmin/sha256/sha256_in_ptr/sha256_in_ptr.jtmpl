from XMSS require "sha256/sha256_array/sha256_array.jtmpl"

fn _blocks_0_ref(
  reg ptr u32[8] _H, 
  #public #spill_to_mmx reg u64 in inlen,
  #msf reg u64 ms
) -> reg ptr u32[8], reg u64, reg u64, #msf reg u64
{
  inline int t;
  reg u32 T1 T2 a b c d e f g h r v;
  stack u32[64] W;
  reg ptr u32[64] Kp;
  stack ptr u32[8] Hp;
  reg ptr u32[8] H;
  reg u64 tr; 

  reg bool cond;

  Kp = SHA256_K;
  Hp = _H;

  H = Hp;

  while { cond = inlen >= 64; } (cond)
  {
    ms = #update_msf(cond, ms);

    for t=0 to 16
    { v = (u32)[in + t*4];
      v = #BSWAP_32(v);
      W[t] = v;
    }

    () = #spill(in);

    for t=16 to 64
    { W = __Wt_ref(W, t); }

    a, b, c, d, e, f, g, h, H = __load_H_ref(H);
    Hp = H;

    tr = 0;
    while { cond = tr < 64; } (cond)
    {
      ms = #update_msf(cond, ms);

      //T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt
      T1  = h;
      r   = __BSIG1_ref(e);
      T1 += r;
      r   = __CH_ref(e,f,g);
      T1 += r;
      T1 += Kp[tr];
      T1 += W[tr];

      //T2 = BSIG0(a) + MAJ(a,b,c)
      T2  = __BSIG0_ref(a);
      r   = __MAJ_ref(a,b,c);
      T2 += r;

      h  = g;
      g  = f;
      f  = e;
      e  = d;
      e += T1;
      d  = c;
      c  = b;
      b  = a;
      a  = T1;
      a += T2;

      tr += 1;
    }

    ms = #update_msf(!cond, ms);

    H = Hp;
    a += H[0];
    b += H[1];
    c += H[2];
    d += H[3];
    e += H[4];
    f += H[5];
    g += H[6];
    h += H[7];

    H = __store_H_ref(H,a,b,c,d,e,f,g,h);

    () = #unspill(in);
    in += 64;
    inlen -= 64;

  } 

  ms = #update_msf(!cond, ms);
  _H = H;

  return _H, in, inlen, ms;
}

inline fn __lastblocks_ref(
  reg u64 in inlen bits,
  #msf reg u64 ms
) -> stack u32[32], reg u64, #msf reg u64
{
  stack u32[32] sblocks;
  inline int k;
  reg u64 i j nblocks;
  reg u8 v;

  reg bool cond;

  i = 0;

  // Zero-fill the sblocks array
  for k = 0 to 32 { sblocks[k] = i; }

  // copy in to sblocks
  while { cond = i < inlen; } (cond)
  { 
    ms = #update_msf(cond, ms);
    v = (u8)[in + i];
    sblocks[u8 i] = v;
    i += 1;
  }

  ms = #update_msf(!cond, ms);

  // set first byte after input to 0x80 
  sblocks[u8 i] = 0x80;

  // check if one or two blocks are needed
  cond = inlen < 56;
  if (cond) // 448 / 8 = 56
  { 
    ms = #update_msf(cond, ms);
    j = (64-8); nblocks = 1; i = 63; 
  } else { 
    ms = #update_msf(!cond, ms);
    j = (128-8); nblocks = 2; i = 127; 
  }

  while { cond = i >= j; } (cond)
  { 
    ms = #update_msf(cond, ms);
    sblocks[u8 i] = (8u) bits;
    bits >>= 8;
    i -= 1;
  }

  ms = #update_msf(!cond, ms);

  return sblocks, nblocks, ms;
}

inline fn __sha256_in_ptr(
  #spill_to_mmx reg ptr u8[32] out, 
  #public reg u64 in inlen,
  #msf reg u64 ms
) -> reg ptr u8[32]
{
  #spill_to_mmx reg u64 bits;
  reg u64 nblocks;
  stack u32[8] H;
  reg ptr u32[8] Hp;
  stack u32[32] sblocks;
  reg ptr u32[32] sblocksp;

  bits = inlen;
  bits <<= 3;
  () = #spill(bits, out);

  H = __initH_ref();
  Hp = H;
  Hp, in, inlen, ms = _blocks_0_ref(Hp, in, inlen, ms);

  () = #unspill(bits);
  sblocks, nblocks, ms = __lastblocks_ref(in, inlen, bits, ms);
  
  sblocksp = sblocks;
  Hp, _, ms = _blocks_1_ref(Hp, sblocksp, nblocks, ms);

  () = #unspill(out);

  H = Hp;
  out = __store_ref_array(out, H);

  return out;
}