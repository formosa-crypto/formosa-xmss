// Obs:
// Esta funcao calcula a condicao 
//    offset >= 2 && heights[offset - 1] == heights[offset - 2]
// 
// Em C, se a primeira parte do `&&` for falsa, a segunda nao e avaliada
// Neste caso, temos que garantir que a segunda parte do `&&` so e avaliada
// se a primeira for verdade. Caso contrario, (i.e quando offset < 2), 
// os accessos a memoria do lado direito sao unsafe.
// Portanto, a funcao `__cond_u64_geq_u64_u32_eq_u32` nao pode ser usada visto
// que avalia ambos os lados da `&&`.
//
// Neste caso, testo se offset >=2 e so nesse caso, e que se avalia o segundo lado 
// da expressao. Caso contrartio, retorna se o valor de #SETcc(offset >= 2) = Zero
//
// Estou a assumir que o valor de offset e publico (confirmar isto mas acho que sim)
inline
fn __treehash_cond(reg ptr u32[XMSS_TREE_HEIGHT + 1] heights, reg u64 offset) -> reg u8 {
    reg bool c1 c2;
    reg u8 bc1 res;
    reg u32 a b;

    ?{ ">=u" = c1 } = #CMP_64(offset, 2);
    bc1 = #SETcc(c1);

    if (bc1 == 0) { 
        res = bc1;
    } else {
        a = heights[offset - 1];
        b = heights[offset - 2];

        ?{ "==" = c2} = #CMP_32(a, b);

        res = #SETcc(c2);
    }

    return res;
}
