////////////////////////////////////////////////////////////////////////////////////////////////////

inline
fn __memcpy_u8u8_offset(
    reg ptr u8[XMSS_WOTS_SIG_BYTES] out,
    reg u64 offset,
    reg ptr u8[XMSS_N] in
) -> reg ptr u8[XMSS_WOTS_SIG_BYTES]
{
    reg u64 i;
    
    i = 0;
    while (i < XMSS_N) {
        out[offset] = in[i];
        i += 1;
        offset += 1;
    }

    return out;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

inline
fn __memcpy_u8u8p(
    reg ptr u8[XMSS_N] out,
    reg u64 in_ptr
) -> reg ptr u8[XMSS_N]
{
    inline int i;

    for i = 0 to XMSS_N {
        out[i] = (u8) [in_ptr + i];
    }

    return out;
}

#[returnaddress="stack"]
fn _memcpy_u8u8p(
    reg ptr u8[XMSS_N] out,
    reg u64 in_ptr
) -> reg ptr u8[XMSS_N]
{
    out = __memcpy_u8u8p(out, in_ptr);
    return out;
}

inline
fn _x_memcpy_u8u8p(
    reg ptr u8[XMSS_N] out,
    reg u64 in_ptr
) -> reg ptr u8[XMSS_N]
{
    out = out;
    in_ptr = in_ptr;

    out = _memcpy_u8u8p(out, in_ptr);

    out = out;
  
    return out;
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// same as memcpy(out_ptr + out_offset, in_ptr + in_offset, bytes)
inline
fn __memcpy_u8pu8p(
    reg u64 out_ptr,
    reg u64 out_offset,
    reg u64 in_ptr,
    reg u64 in_offset,
    reg u64 bytes
)
{
    reg u64 i;

    i = 0;
    
    while(i < bytes) {
        (u8) [out_ptr + out_offset] = (u8) [in_ptr + in_offset];
        i += 1;
        in_offset += 1;
        out_offset += 1;
    }
}

fn _memcpy_u8pu8p(
    reg u64 out_ptr,
    reg u64 out_offset,
    reg u64 in_ptr,
    reg u64 in_offset,
    reg u64 bytes
)
{
    __memcpy_u8pu8p(out_ptr, out_offset, in_ptr, in_offset, bytes);
}

inline
fn _x__memcpy_u8pu8p(
    reg u64 out_ptr,
    reg u64 out_offset,
    reg u64 in_ptr,
    reg u64 in_offset,
    reg u64 bytes
)
{
    out_ptr = out_ptr;
    out_offset = out_offset;
    in_ptr = in_ptr;
    in_offset = in_offset;
    bytes = bytes;

    _memcpy_u8pu8p(out_ptr, out_offset, in_ptr, in_offset, bytes);
}

inline
fn __nbytes_copy_inplace(
    reg ptr u8[XMSS_WOTS_SIG_BYTES] out,
    reg u64 offset_out,
    reg u64 offset_in
) -> reg ptr u8[XMSS_WOTS_SIG_BYTES]
{
    inline int i;

    for i=0 to XMSS_N {
        out[offset_out + i] = out[offset_in + i];
    }

    return out;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

namespace memcpy_u8pu8_n {
    param int INLEN = XMSS_N;
    require "__memcpyu8pu8.jinc"
}

namespace memcpy_u8u8_N {
    param int OUTLEN = XMSS_N;
    param int INLEN  = XMSS_N;
    require "__memcpy.jinc"
}

namespace memcpy_u8u8_2N {
    param int OUTLEN = 2 * XMSS_N;
    param int INLEN  = 2 * XMSS_N;
    require "__memcpy.jinc"
}

namespace memcpy_u8u8_2N_N {
    param int OUTLEN = 2 * XMSS_N;
    param int INLEN  = XMSS_N;
    require "__memcpy.jinc"
}

namespace memcpy_u8pu8_plen {
    param int INLEN = XMSS_PADDING_LEN;
    require "__memcpyu8pu8.jinc"
}

namespace memcpy_u8u8_2_ltree {
    param int OUTLEN = 2 * XMSS_N;
    param int INLEN  = XMSS_WOTS_SIG_BYTES;
    require "__memcpy.jinc"
}

namespace memcpy_u8u8_3_treehash {
    param int OUTLEN  = (XMSS_TREE_HEIGHT + 1) * XMSS_N;
    param int INLEN   =  XMSS_N;
    require "__memcpy.jinc"
}

namespace memcpy_u8u8_2_treehash {
    param int OUTLEN  = 2 * XMSS_N;
    param int INLEN   = (XMSS_TREE_HEIGHT + 1) * XMSS_N;
    require "__memcpy.jinc"
}

namespace nbytes_copy_offset_pk {
    param int OUTLEN = XMSS_PK_BYTES;
    param int INLEN  = XMSS_N;
    require "__memcpy.jinc"
}

namespace nbytes_copy_offset_sk {
    param int OUTLEN = XMSS_SK_BYTES;
    param int INLEN  = XMSS_N;
    require "__memcpy.jinc"
}