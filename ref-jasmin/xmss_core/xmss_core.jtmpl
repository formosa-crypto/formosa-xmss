from Stdlib require "bytes/bytes.jtmpl"
from Stdlib require "conditions/conditions.jinc"
from Stdlib require "memset/memset.jtmpl"
from Stdlib require "memcpy/memcpy.jtmpl"

from XMSS require "hash_address/hash_address.jinc"
from XMSS require "xmss_commons/xmss_commons.jtmpl"

/////////////////////////////////// TREEHASH ///////////////////////////////////

// NOTE: This is considerably different than the treehash function from the 
//       reference implementation
//
//       This is a rough translation of algorithm 9 of RFC 8391
//       cf. https://datatracker.ietf.org/doc/html/rfc8391#section-4.1.6
//
//  Algorithm 9: treeHash
//
//  Input: XMSS private key SK, start index s, target node height t,
//         address ADRS
//  Output: n-byte node node - top node on Stack
//     
//  if( s % (1 << t) != 0 ) return -1;
//  for ( i = 0; i < 2^t; i++ ) {
//    SEED = getSEED(SK);
//    ADRS.setType(0);   // Type = OTS hash address
//    ADRS.setOTSAddress(s + i);
//    pk = WOTS_genPK (getWOTS_SK(SK, s + i), SEED, ADRS);
//    ADRS.setType(1);   // Type = L-tree address
//    ADRS.setLTreeAddress(s + i);
//    node = ltree(pk, SEED, ADRS);
//    ADRS.setType(2);   // Type = hash tree address
//    ADRS.setTreeHeight(0);
//    ADRS.setTreeIndex(i + s);
//    while ( Top node on Stack has same height t' as node ) {
//       ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) / 2);
//       node = RAND_HASH(Stack.pop(), node, SEED, ADRS);
//       ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);
//    }
//    Stack.push(node);
//  }
//  return Stack.pop();
//
inline fn __treehash(
    reg ptr u8[XMSS_N] root,
    reg ptr u8[XMSS_N] sk_seed,
    reg ptr u8[XMSS_N] pub_seed,
    reg u32 s t, // start index and target node height
    reg ptr u32[8] subtree_addr
) -> reg ptr u8[XMSS_N]
{
    stack u8[(XMSS_TREE_HEIGHT + 1) * XMSS_N] _stack;   
    stack u32[(XMSS_TREE_HEIGHT + 1)] heights;
    stack u32[8] ots_addr ltree_addr node_addr;

    stack u8[XMSS_N] buf;
    reg u64 index;
    inline int j;

    reg u32 i tree_idx;
    reg u32 t u;
    reg u64 offset t64;
    reg u32 upper_bound t32;

    reg bool cond;
    reg u32 a b;

    stack u8[2 * XMSS_N] buf2;

    // unsigned int offset = 0;
    offset = 0;

    () = #spill(root, offset, sk_seed, pub_seed);

    // uint32_t ots_addr[8] = {0};
    // uint32_t ltree_addr[8] = {0};
    // uint32_t node_addr[8] = {0};
    ots_addr = __zero_address_(ots_addr);
    ltree_addr = __zero_address_(ltree_addr);
    node_addr = __zero_address_(node_addr);

    // copy_subtree_addr(ots_addr, subtree_addr);
    // copy_subtree_addr(ltree_addr, subtree_addr);
    // copy_subtree_addr(node_addr, subtree_addr);
    ots_addr = __copy_subtree_addr(ots_addr, subtree_addr);
    ltree_addr = __copy_subtree_addr(ltree_addr, subtree_addr);
    node_addr = __copy_subtree_addr(node_addr, subtree_addr);

    // set_type(ots_addr, XMSS_ADDR_TYPE_OTS);
    // set_type(ltree_addr, XMSS_ADDR_TYPE_LTREE);
    // set_type(node_addr, XMSS_ADDR_TYPE_HASHTREE);
    ots_addr = __set_type(ots_addr, XMSS_ADDR_TYPE_OTS);
    ltree_addr = __set_type(ltree_addr, XMSS_ADDR_TYPE_LTREE);
    node_addr = __set_type(node_addr, XMSS_ADDR_TYPE_HASHTREE);

    i = 0;
    upper_bound = 1;
    upper_bound <<= (t & 31);

    while (i < upper_bound) {
        () = #spill(i, upper_bound);

        t32 = s; t32 += i;

        () = #spill(s);

        ltree_addr = __set_ltree_addr(ltree_addr, t32); // NOTE: This is different than the reference implementation
        ots_addr = __set_ots_addr(ots_addr, t32); // NOTE: This is different than the reference implementation

        // gen_buf_wots(params, stack + offset*params->n, sk_seed, pub_seed, ltree_addr, ots_addr);
            // We need to load the buf first 
            () = #unspill(offset, sk_seed, pub_seed);
            index = offset; index *= XMSS_N;
            buf = __nbytes_copy_offset<XMSS_N, (XMSS_TREE_HEIGHT + 1) * XMSS_N>(buf, 0, _stack, index);

            buf, ltree_addr, ots_addr = __gen_leaf_wots_(buf, sk_seed, pub_seed, ltree_addr, ots_addr); // __gen_leaf_wots_ = pkgen + ltree

            // Write the result back
            () = #unspill(offset);
            index = offset; index *= XMSS_N;
            _stack = __nbytes_copy_offset<(XMSS_TREE_HEIGHT + 1) * XMSS_N, XMSS_N>(_stack, index, buf, 0);

        // offset++;
        offset += 1;
        
        // heights[offset - 1] = 0;
        index = offset; index -= 1;
        heights[index] = 0; 

        () = #spill(offset);

        /////////////////////////////// INNER LOOP /////////////////////////////
        // if the top two nodes on the stack have the same height, indicating that they can be combined to form a parent node
        // This is done usin thash_h (= randhash from the RFC)
        () = #unspill(offset, i);
        while { 
            a = heights[offset - 1];
            b = heights[offset - 2];
            cond = __cond_u64_geq_u64_u32_eq_u32(offset, 2, a, b);
        } (cond) {
            // tree_idx = (idx >> (heights[offset - 1] + 1));
            index = offset; index -= 1;
            t = heights[index]; 
            t += 1; // At this point, t = heights[offset - 1] + 1

            u = i;
            u >>= (t & 31);
            tree_idx = u;

            () = #spill(tree_idx);

            // set_tree_height(node_addr, heights[offset - 1]);
            node_addr = __set_tree_height(node_addr, heights[offset - 1]);

            () = #unspill(s, i);
            t32 = s; t32 += i;
            node_addr = __set_tree_index(node_addr, t32); // NOTE: This is different than the reference implementation
                                                          // Should become // ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) / 2);
                                                          // FIXME: this is wrong

            // thash_h(params, stack + (offset-2)*params->n, stack + (offset-2)*params->n, pub_seed, node_addr);
            // 1) Load input to buf2
            index = offset; index -= 2; index *= XMSS_N;
            for j=0 to 2*XMSS_N { buf2[j] = _stack[index + j]; }

            () = #unspill(pub_seed);
            buf, node_addr = __thash_h_(buf, buf2, pub_seed, node_addr);

            // 2) Write the result back to the stack
            () = #unspill(offset);
            index = offset; index -= 2; index *= XMSS_N;
            _stack = __nbytes_copy_offset<(XMSS_TREE_HEIGHT + 1) * XMSS_N, XMSS_N>(_stack, index, buf, 0);

            // offset--;
            offset -= 1;
            () = #spill(offset);
            
            // heights[offset - 1]++;
            index = offset;
            index -= 1;
            t = heights[index];
            t += 1;
            heights[index] = t;
        }

        /////////////////////////////// INNER LOOP /////////////////////////////

        () = #unspill(i, upper_bound, s);
        i += 1;
    }
    
    () = #unspill(root);

    // memcpy(root, stack, params->n);
    for j=0 to XMSS_N { root[j] = _stack[j]; }
    return root;
}

fn _treehash(
    reg ptr u8[XMSS_N] node,
    reg ptr u8[XMSS_N] sk_seed,
    reg ptr u8[XMSS_N] pub_seed,
    reg u32 s t,
    reg ptr u32[8] subtree_addr
) -> reg ptr u8[XMSS_N]
{
    node = __treehash(node, sk_seed, pub_seed, s, t, subtree_addr);
    return node;
}

inline fn __treehash_(
    reg ptr u8[XMSS_N] node,
    reg ptr u8[XMSS_N] sk_seed,
    reg ptr u8[XMSS_N] pub_seed,
    reg u32 s t,
    reg ptr u32[8] subtree_addr
) -> reg ptr u8[XMSS_N]
{
    node = node;
    sk_seed = sk_seed;
    pub_seed = pub_seed;
    s = s;
    t = t;
    subtree_addr = subtree_addr;

    node = _treehash(node, sk_seed, pub_seed, s, t, subtree_addr);

    node = node;

    return node;
}
