from Stdlib require "bytes/bytes.jtmpl"
from Stdlib require "conditions/conditions.jinc"
from Stdlib require "memset/memset.jtmpl"
from Stdlib require "memcpy/memcpy.jtmpl"

from XMSS require "hash_address/hash_address.jinc"
from XMSS require "xmss_commons/xmss_commons.jtmpl"

/////////////////////////////////// TREEHASH ///////////////////////////////////

// NOTE: This is considerably different than the treehash function from the 
//       reference implementation
//
//       This is a rough translation of algorithm 9 of RFC 8391
//       cf. https://datatracker.ietf.org/doc/html/rfc8391#section-4.1.6
//
//  Algorithm 9: treeHash
//
//  Input: XMSS private key SK, start index s, target node height t,
//         address ADRS
//  Output: n-byte node node - top node on Stack
//     
//  if( s % (1 << t) != 0 ) return -1;
//  for ( i = 0; i < 2^t; i++ ) {
//    SEED = getSEED(SK);
//    ADRS.setType(0);   // Type = OTS hash address
//    ADRS.setOTSAddress(s + i);
//    pk = WOTS_genPK (getWOTS_SK(SK, s + i), SEED, ADRS);
//    ADRS.setType(1);   // Type = L-tree address
//    ADRS.setLTreeAddress(s + i);
//    node = ltree(pk, SEED, ADRS);
//    ADRS.setType(2);   // Type = hash tree address
//    ADRS.setTreeHeight(0);
//    ADRS.setTreeIndex(i + s);
//    while ( Top node on Stack has same height t' as node ) {
//       ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) / 2);
//       node = RAND_HASH(Stack.pop(), node, SEED, ADRS);
//       ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);
//    }
//    Stack.push(node);
//  }
//  return Stack.pop();
//
inline fn __treehash(
    reg ptr u8[XMSS_N] root,
    reg ptr u8[XMSS_N] sk_seed,
    reg ptr u8[XMSS_N] pub_seed,
    reg u32 s target_height, // start index and target node height
    reg ptr u32[8] subtree_addr
) -> reg ptr u8[XMSS_N]
{
    stack u8[(XMSS_TREE_HEIGHT + 1) * XMSS_N] _stack;   
    stack u32[(XMSS_TREE_HEIGHT + 1)] heights;
    stack u32[8] ots_addr ltree_addr node_addr;

    stack u8[XMSS_N] buf;

    reg u64 index;
    inline int j;

    reg u32 i tree_idx;
    reg u32 t u;
    reg u64 offset t64;
    reg u32 upper_bound t32;

    reg bool cond;
    reg u32 a b;

    stack u8[2 * XMSS_N] buf2;

    // unsigned int offset = 0;
    offset = 0;

    () = #spill(root, offset, sk_seed, pub_seed);

    // uint32_t ots_addr[8] = {0};
    // uint32_t ltree_addr[8] = {0};
    // uint32_t node_addr[8] = {0};
    ots_addr = __zero_address_(ots_addr);
    ltree_addr = __zero_address_(ltree_addr);
    node_addr = __zero_address_(node_addr);

    // copy_subtree_addr(ots_addr, subtree_addr);
    // copy_subtree_addr(ltree_addr, subtree_addr);
    // copy_subtree_addr(node_addr, subtree_addr);
    ots_addr = __copy_subtree_addr(ots_addr, subtree_addr);
    ltree_addr = __copy_subtree_addr(ltree_addr, subtree_addr);
    node_addr = __copy_subtree_addr(node_addr, subtree_addr);

    // set_type(ots_addr, XMSS_ADDR_TYPE_OTS);
    // set_type(ltree_addr, XMSS_ADDR_TYPE_LTREE);
    // set_type(node_addr, XMSS_ADDR_TYPE_HASHTREE);
    ots_addr = __set_type(ots_addr, XMSS_ADDR_TYPE_OTS);
    ltree_addr = __set_type(ltree_addr, XMSS_ADDR_TYPE_LTREE);
    node_addr = __set_type(node_addr, XMSS_ADDR_TYPE_HASHTREE);

    target_height = target_height; // move to rdx register

    i = 0;
    upper_bound = 1;
    upper_bound <<= (target_height & 31);

    while (i < upper_bound) {
        () = #spill(i, upper_bound);

        t32 = s; t32 += i;

        () = #spill(s);

        ltree_addr = __set_ltree_addr(ltree_addr, t32); // NOTE: This is different than the reference implementation
        ots_addr = __set_ots_addr(ots_addr, t32); // NOTE: This is different than the reference implementation

        // gen_buf_wots(params, stack + offset*params->n, sk_seed, pub_seed, ltree_addr, ots_addr);
            // We need to load the buf first 
            () = #unspill(offset, sk_seed, pub_seed);
            index = offset; index *= XMSS_N;
            buf = __nbytes_copy_offset<XMSS_N, (XMSS_TREE_HEIGHT + 1) * XMSS_N>(buf, 0, _stack, index);

            buf, ltree_addr, ots_addr = __gen_leaf_wots_(buf, sk_seed, pub_seed, ltree_addr, ots_addr); // __gen_leaf_wots_ = pkgen + ltree

            // Write the result back
            () = #unspill(offset);
            index = offset; index *= XMSS_N;
            _stack = __nbytes_copy_offset<(XMSS_TREE_HEIGHT + 1) * XMSS_N, XMSS_N>(_stack, index, buf, 0);

        // offset++;
        offset += 1;
        
        // heights[offset - 1] = 0;
        index = offset; index -= 1;
        () = #unspill(s);
        heights[index] = s; // FIXME: TODO: check if this is right. it works for kg  

        () = #spill(offset);

        /////////////////////////////// INNER LOOP /////////////////////////////
        // if the top two nodes on the stack have the same height, indicating that they can be combined to form a parent node
        // This is done usin thash_h (= randhash from the RFC)
        () = #unspill(offset, i);
        while { 
            a = heights[offset - 1];
            b = heights[offset - 2];
            cond = __cond_u64_geq_u64_u32_eq_u32(offset, 2, a, b);
        } (cond) {
            // tree_idx = (idx >> (heights[offset - 1] + 1));
            index = offset; index -= 1;
            t = heights[index]; 
            t += 1; // At this point, t = heights[offset - 1] + 1

            u = i;
            u >>= (t & 31);
            tree_idx = u;

            () = #spill(tree_idx);

            // set_tree_height(node_addr, heights[offset - 1]);
            node_addr = __set_tree_height(node_addr, heights[offset - 1]);

            () = #unspill(s, i);
            node_addr = __set_tree_index(node_addr, tree_idx); 

            // thash_h(params, stack + (offset-2)*params->n, stack + (offset-2)*params->n, pub_seed, node_addr);
            // 1) Load input to buf2
            index = offset; index -= 2; index *= XMSS_N;
            for j=0 to 2*XMSS_N { buf2[j] = _stack[index + j]; }

            () = #unspill(pub_seed);
            buf, node_addr = __thash_h_(buf, buf2, pub_seed, node_addr);

            // 2) Write the result back to the stack
            () = #unspill(offset);
            index = offset; index -= 2; index *= XMSS_N;
            _stack = __nbytes_copy_offset<(XMSS_TREE_HEIGHT + 1) * XMSS_N, XMSS_N>(_stack, index, buf, 0);

            // offset--;
            offset -= 1;
            () = #spill(offset);
            
            // heights[offset - 1]++;
            index = offset;
            index -= 1;
            t = heights[index]; 
            t += 1; 
            heights[index] = t; 
        }

        /////////////////////////////// INNER LOOP /////////////////////////////

        () = #unspill(i, upper_bound, s);
        i += 1;
    }
    
    () = #unspill(root);

    // memcpy(root, stack, params->n);
    for j=0 to XMSS_N { root[j] = _stack[j]; }
    return root;
}

fn _treehash(
    reg ptr u8[XMSS_N] node,
    reg ptr u8[XMSS_N] sk_seed,
    reg ptr u8[XMSS_N] pub_seed,
    reg u32 s t,
    reg ptr u32[8] subtree_addr
) -> reg ptr u8[XMSS_N]
{
    node = __treehash(node, sk_seed, pub_seed, s, t, subtree_addr);
    return node;
}

inline fn __treehash_(
    reg ptr u8[XMSS_N] node,
    reg ptr u8[XMSS_N] sk_seed,
    reg ptr u8[XMSS_N] pub_seed,
    reg u32 s t,
    reg ptr u32[8] subtree_addr
) -> reg ptr u8[XMSS_N]
{
    node = node;
    sk_seed = sk_seed;
    pub_seed = pub_seed;
    s = s;
    t = t;
    subtree_addr = subtree_addr;

    node = _treehash(node, sk_seed, pub_seed, s, t, subtree_addr);

    node = node;

    return node;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline fn __xmssmt_core_seed_keypair(
    reg ptr u8[XMSS_PK_BYTES] pk, 
    reg ptr u8[XMSS_SK_BYTES] sk,
    reg ptr u8[3 * XMSS_N] seed
) -> reg ptr u8[XMSS_PK_BYTES], reg ptr u8[XMSS_SK_BYTES]
{
    stack u8[XMSS_TREE_HEIGHT * XMSS_N] auth_path;
    stack u32[8] top_tree_addr;
    stack u8[XMSS_N] root;

    reg ptr u8[XMSS_INDEX_BYTES] idx;
    reg ptr u8[2 * XMSS_N] buf0 buf1;
    reg ptr u8[XMSS_N] bufn0 bufn1;

    top_tree_addr = __zero_address_(top_tree_addr);

    top_tree_addr =  __set_layer_addr(top_tree_addr, XMSS_D - 1);
    
    // memset(sk, 0, params->index_bytes);
    idx = sk[0 : XMSS_INDEX_BYTES];
    idx = __memset_zero_u8(idx);
    sk[0 : XMSS_INDEX_BYTES] = idx;
    
    // memcpy(sk, seed, 2 * params->n);
    buf0 = sk[XMSS_INDEX_BYTES : 2 * XMSS_N]; 
    buf1 = seed[0 : 2 * XMSS_N];
    buf0 = _x_memcpy_u8u8<2*XMSS_N, 2*XMSS_N>(buf0, buf1);
    sk[XMSS_INDEX_BYTES : 2 * XMSS_N] = buf0;

    // memcpy(sk + 3 * params->n, seed + 2 * params->n, params->n);
    bufn0 = sk[XMSS_INDEX_BYTES + 3*XMSS_N : XMSS_N]; 
    bufn1 = seed[2*XMSS_N : XMSS_N];
    bufn0 = _x_memcpy_u8u8<XMSS_N, XMSS_N>(bufn0, bufn1);
    sk[XMSS_INDEX_BYTES + 3*XMSS_N : XMSS_N] = bufn0;

    // memcpy(pk + params->n, sk + 3*params->n, params->n);
    bufn0 = pk[XMSS_N : XMSS_N]; 
    bufn1 = sk[XMSS_INDEX_BYTES + 3*XMSS_N : XMSS_N];
    bufn0 = _x_memcpy_u8u8<XMSS_N, XMSS_N>(bufn0, bufn1);
    pk[XMSS_N : XMSS_N] = bufn0;

    // treehash(params, pk, auth_path, sk, pk + params->n, 0, top_tree_addr);
    bufn0 = sk[XMSS_INDEX_BYTES : XMSS_N];
    bufn1 = pk[XMSS_N : XMSS_N];
    () = #spill(pk, sk);
    root = __treehash_(root, bufn0, bufn1, 0, XMSS_TREE_HEIGHT, top_tree_addr);
    
    // memcpy(sk + 2*params->n, pk, params->n);
    () = #unspill(pk, sk);

    // set the field root
    pk = __nbytes_copy_offset<XMSS_PK_BYTES, XMSS_N>(pk, 0, root, 0);
    sk = __nbytes_copy_offset<XMSS_SK_BYTES, XMSS_N>(sk, XMSS_INDEX_BYTES + 2 * XMSS_N, root, 0);

    return pk, sk;
}

/////////////////////////////////// KEY PAIR ///////////////////////////////////

inline fn __xmssmt_core_keypair(
    reg ptr u8[XMSS_PK_BYTES] pk, 
    reg ptr u8[XMSS_SK_BYTES] sk
) -> reg ptr u8[XMSS_PK_BYTES], reg ptr u8[XMSS_SK_BYTES]
{
    stack u8 [3 * XMSS_N] seed;
    reg ptr u8[3 * XMSS_N] seed_p;

    seed_p = seed;
    seed_p = #randombytes(seed_p);

    pk, sk = __xmssmt_core_seed_keypair(pk, sk, seed_p);

    return pk, sk;
}

fn _xmssmt_core_keypair(
    reg ptr u8[XMSS_PK_BYTES] pk, 
    reg ptr u8[XMSS_SK_BYTES] sk
) -> reg ptr u8[XMSS_PK_BYTES], reg ptr u8[XMSS_SK_BYTES]
{
    pk, sk = __xmssmt_core_keypair(pk, sk);

    return pk, sk;
}

inline fn __xmssmt_core_keypair_(
    reg ptr u8[XMSS_PK_BYTES] pk, 
    reg ptr u8[XMSS_SK_BYTES] sk
) -> reg ptr u8[XMSS_PK_BYTES], reg ptr u8[XMSS_SK_BYTES]
{
    pk = pk;
    sk = sk;

    pk, sk = _xmssmt_core_keypair(pk, sk);

    pk = pk;
    sk = sk;
    
    return pk, sk;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline fn __build_auth_path(
    reg ptr u8[XMSS_TREE_HEIGHT * XMSS_N] auth_path,
    reg ptr u8[XMSS_N] sk_seed,
    reg ptr u8[XMSS_N] pub_seed,
    reg u32 i,
    reg ptr u32[8] addr
) -> reg ptr u8[XMSS_TREE_HEIGHT * XMSS_N]
{
    inline int j;
    reg u32 s k;
    reg ptr u8[XMSS_N] node;

    () = #spill(auth_path, i, sk_seed, pub_seed, addr);

    for j=0 to XMSS_TREE_HEIGHT {
        () = #unspill(i, auth_path, sk_seed, pub_seed, addr);

        //  k = floor(index / (2 ^ j)) ^ 1
        // NOTE: k = index / (2 ^ j) is the same as k = i >> j
        k = i; k >>= j; k ^= 1;

        // s = k * (2 ^ j)
        s = k; s <<= j;

        node = auth_path[j*XMSS_N : XMSS_N];
        node = __treehash_(node, sk_seed, pub_seed, s, j, addr);

        () = #unspill(auth_path);
        auth_path[j*XMSS_N : XMSS_N] = node;
        () = #spill(auth_path);
    }

    return auth_path;
}

fn _build_auth_path(
    reg ptr u8[XMSS_TREE_HEIGHT * XMSS_N] auth_path,
    reg ptr u8[XMSS_N] sk_seed,
    reg ptr u8[XMSS_N] pub_seed,
    reg u32 i,
    reg ptr u32[8] addr
) -> reg ptr u8[XMSS_TREE_HEIGHT * XMSS_N]
{
    auth_path = __build_auth_path(auth_path, sk_seed, pub_seed, i, addr);
    return auth_path;
}

inline fn __build_auth_path_(
    reg ptr u8[XMSS_TREE_HEIGHT * XMSS_N] auth_path,
    reg ptr u8[XMSS_N] sk_seed,
    reg ptr u8[XMSS_N] pub_seed,
    reg u32 i,
    reg ptr u32[8] addr
) -> reg ptr u8[XMSS_TREE_HEIGHT * XMSS_N]
{
    auth_path = auth_path;
    sk_seed = sk_seed;
    pub_seed = pub_seed;
    i = i;
    addr = addr;

    auth_path = _build_auth_path(auth_path, sk_seed, pub_seed, i, addr);
    
    auth_path = auth_path;

    return auth_path;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// treesig
// sign
// open 