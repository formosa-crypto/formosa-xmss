from Stdlib require "bytes/bytes.jtmpl"
from Stdlib require "conditions/conditions.jinc"
from Stdlib require "memset/memset.jtmpl"
from Stdlib require "memcpy/memcpy.jtmpl"

from XMSS require "treehash/treehash.jinc"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline fn __xmssmt_core_seed_keypair(
    reg ptr u8[XMSS_PK_BYTES] pk, 
    reg ptr u8[XMSS_SK_BYTES] sk,
    reg ptr u8[3 * XMSS_N] seed
) -> reg ptr u8[XMSS_PK_BYTES], reg ptr u8[XMSS_SK_BYTES]
{
    stack u8[XMSS_TREE_HEIGHT * XMSS_N] auth_path;
    stack u32[8] top_tree_addr;
    stack u8[XMSS_N] root;

    reg ptr u8[XMSS_INDEX_BYTES] idx;
    reg ptr u8[2 * XMSS_N] buf0 buf1;
    reg ptr u8[XMSS_N] bufn0 bufn1;

    top_tree_addr = __zero_address_(top_tree_addr);

    top_tree_addr =  __set_layer_addr(top_tree_addr, XMSS_D - 1);
    
    // memset(sk, 0, params->index_bytes);
    idx = sk[0 : XMSS_INDEX_BYTES];
    idx = __memset_zero_u8(idx);
    sk[0 : XMSS_INDEX_BYTES] = idx;
    
    // memcpy(sk, seed, 2 * params->n);
    buf0 = sk[XMSS_INDEX_BYTES : 2 * XMSS_N]; 
    buf1 = seed[0 : 2 * XMSS_N];
    buf0 = _x_memcpy_u8u8<2*XMSS_N, 2*XMSS_N>(buf0, buf1);
    sk[XMSS_INDEX_BYTES : 2 * XMSS_N] = buf0;

    // memcpy(sk + 3 * params->n, seed + 2 * params->n, params->n);
    bufn0 = sk[XMSS_INDEX_BYTES + 3*XMSS_N : XMSS_N]; 
    bufn1 = seed[2*XMSS_N : XMSS_N];
    bufn0 = _x_memcpy_u8u8<XMSS_N, XMSS_N>(bufn0, bufn1);
    sk[XMSS_INDEX_BYTES + 3*XMSS_N : XMSS_N] = bufn0;

    // memcpy(pk + params->n, sk + 3*params->n, params->n);
    bufn0 = pk[XMSS_N : XMSS_N]; 
    bufn1 = sk[XMSS_INDEX_BYTES + 3*XMSS_N : XMSS_N];
    bufn0 = _x_memcpy_u8u8<XMSS_N, XMSS_N>(bufn0, bufn1);
    pk[XMSS_N : XMSS_N] = bufn0;

    // treehash(params, pk, auth_path, sk, pk + params->n, 0, top_tree_addr);
    bufn0 = sk[XMSS_INDEX_BYTES : XMSS_N];
    bufn1 = pk[XMSS_N : XMSS_N];
    () = #spill(pk, sk);
    root = __treehash_(root, bufn0, bufn1, 0, XMSS_TREE_HEIGHT, top_tree_addr);
    
    // memcpy(sk + 2*params->n, pk, params->n);
    () = #unspill(pk, sk);

    // set the field root
    pk = __nbytes_copy_offset<XMSS_PK_BYTES, XMSS_N>(pk, 0, root, 0);
    sk = __nbytes_copy_offset<XMSS_SK_BYTES, XMSS_N>(sk, XMSS_INDEX_BYTES + 2 * XMSS_N, root, 0);

    return pk, sk;
}

/////////////////////////////////// KEY PAIR ///////////////////////////////////

inline fn __xmssmt_core_keypair(
    reg ptr u8[XMSS_PK_BYTES] pk, 
    reg ptr u8[XMSS_SK_BYTES] sk
) -> reg ptr u8[XMSS_PK_BYTES], reg ptr u8[XMSS_SK_BYTES]
{
    stack u8 [3 * XMSS_N] seed;
    reg ptr u8[3 * XMSS_N] seed_p;

    seed_p = seed;
    seed_p = #randombytes(seed_p);

    pk, sk = __xmssmt_core_seed_keypair(pk, sk, seed_p);

    return pk, sk;
}

fn _xmssmt_core_keypair(
    reg ptr u8[XMSS_PK_BYTES] pk, 
    reg ptr u8[XMSS_SK_BYTES] sk
) -> reg ptr u8[XMSS_PK_BYTES], reg ptr u8[XMSS_SK_BYTES]
{
    pk, sk = __xmssmt_core_keypair(pk, sk);

    return pk, sk;
}

inline fn __xmssmt_core_keypair_(
    reg ptr u8[XMSS_PK_BYTES] pk, 
    reg ptr u8[XMSS_SK_BYTES] sk
) -> reg ptr u8[XMSS_PK_BYTES], reg ptr u8[XMSS_SK_BYTES]
{
    pk = pk;
    sk = sk;

    pk, sk = _xmssmt_core_keypair(pk, sk);

    pk = pk;
    sk = sk;
    
    return pk, sk;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline 
fn __xmssmt_core_sign(
    reg ptr u8[XMSS_SK_BYTES] sk,
    reg u64 sm_ptr smlen_ptr m_ptr mlen
) -> reg ptr u8[XMSS_SK_BYTES], reg u64
{
    reg ptr u8[XMSS_N] sk_seed sk_prf pub_root pub_seed node;

    reg u32 i idx_leaf;
    reg u64 idx idx_hash t64 r;

    stack u8 exit;

    stack u8[32] idx_bytes;
    stack u32[8] ots_addr;

    stack u8[XMSS_N] root M;
    stack u8[XMSS_N] buf;
    stack u8[XMSS_WOTS_SIG_BYTES + (XMSS_TREE_HEIGHT * XMSS_N)] sig_tmp;
    inline int j;

    exit = 0;

    // uint32_t ots_addr[8] = {0};
    ots_addr = __zero_address_(ots_addr);

    // set_type(ots_addr, XMSS_ADDR_TYPE_OTS);
    ots_addr = __set_type(ots_addr, XMSS_ADDR_TYPE_OTS);

    // memcpy(sm + params->sig_bytes, m, mlen);
    _x__memcpy_u8pu8p(sm_ptr, XMSS_SIG_BYTES, m_ptr, 0, mlen);

    // *smlen = params->sig_bytes + mlen;
    t64 = mlen; t64 += XMSS_SIG_BYTES;
    (u64) [smlen_ptr] = t64;

    () = #spill(mlen);

    // idx = (unsigned long)bytes_to_ull(sk, params->index_bytes);
    idx = __bytes_to_ull(sk[0 : XMSS_INDEX_BYTES]);

    // PROOF: rcondf in the proof
    if (idx >= ((1 << XMSS_FULL_HEIGHT) - 1)) {
        // memset(sk, 0xFF, params->index_bytes);
        sk[0 : XMSS_INDEX_BYTES] =  __memset_u8<XMSS_INDEX_BYTES>(sk[0 : XMSS_INDEX_BYTES], 0xFF);

        // memset(sk + params->index_bytes, 0, (params->sk_bytes - params->index_bytes));
        sk[XMSS_INDEX_BYTES : XMSS_SK_BYTES - XMSS_INDEX_BYTES] = 
            __memset_u8<XMSS_SK_BYTES - XMSS_INDEX_BYTES>(sk[XMSS_INDEX_BYTES : XMSS_SK_BYTES - XMSS_INDEX_BYTES], 0);

        if (idx > ((1 << XMSS_FULL_HEIGHT) - 1)) { 
            exit = 1; 
        } else if ((idx == ((1 << XMSS_FULL_HEIGHT) - 1)) && XMSS_FULL_HEIGHT == 64) { 
            exit = 1; 
        }
    }

    // PROOF: rcondt in the proof
    if (exit != 1) {
        // memcpy(sm, sk, params->index_bytes);
        sm_ptr, _ = _x_memcpy_u8pu8<XMSS_INDEX_BYTES>(sm_ptr, 0, sk[0 : XMSS_INDEX_BYTES]);

        // ull_to_bytes(sk, params->index_bytes, idx + 1);
        t64 = idx; t64 += 1;
        sk[0 : XMSS_INDEX_BYTES] = __ull_to_bytes<XMSS_INDEX_BYTES>(sk[0 : XMSS_INDEX_BYTES], t64);

        // ull_to_bytes(idx_bytes_32, 32, idx);
        idx_bytes = __ull_to_bytes<32>(idx_bytes, idx);

        () = #spill(idx, sk, sm_ptr);

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------- 

    // Message compression
    // byte[n] r = PRF(SK_PRF, toByte(idx_sig, 32));
    // byte[n] M' = H_msg(r || getRoot(SK_MT) || (toByte(idx_sig, n)), M);  

        // prf(params, sm + params->index_bytes, idx_bytes_32, sk_prf);
        sk_prf = sk[XMSS_INDEX_BYTES + XMSS_N : XMSS_N];   
        buf = __prf_(buf, idx_bytes, sk_prf); // prf kills sm_ptr and sk
        
        () = #unspill(sm_ptr, sk); 
        sm_ptr, _ = _x_memcpy_u8pu8<XMSS_N>(sm_ptr, XMSS_INDEX_BYTES, buf);

        // hash_message(params, mhash, sm + params->index_bytes, pub_root, idx, sm + params->sig_bytes - 
        pub_root = sk[XMSS_INDEX_BYTES + 2*XMSS_N : XMSS_N];
        for j=0 to XMSS_N { buf[j] = (u8) [sm_ptr + XMSS_INDEX_BYTES + j]; } // copy the 2nd argument of hash message to buf
        t64 = sm_ptr; t64 += XMSS_SIG_BYTES - XMSS_PADDING_LEN - 3*XMSS_N;

        () = #unspill(mlen, idx);

        M = __hash_message(M, buf, pub_root, idx, t64, mlen); // this function is not used anywhere else so we can use the inline
        root = #copy(M);
        root = #randombytes(root);
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------- 

        // sm += params->index_bytes + params->n;
        // () = #unspill(sm_ptr);
        sm_ptr += XMSS_INDEX_BYTES + XMSS_N;
        () = #spill(sm_ptr);

        // set_type(ots_addr, XMSS_ADDR_TYPE_OTS);
        ots_addr = __set_type(ots_addr, XMSS_ADDR_TYPE_OTS);

        i = 0;
        while (i < XMSS_D) {
            () = #spill(i);
            () = #unspill(sk);

            // root = treeHash(SK, 0, h / d, ADRS);
            sk_seed = sk[XMSS_INDEX_BYTES : XMSS_N];
            pub_seed = sk[XMSS_INDEX_BYTES + 3*XMSS_N : XMSS_N];
            root = __treehash_(root, sk_seed, pub_seed, 0, XMSS_TREE_HEIGHT, ots_addr);

            // idx_leaf = (idx & ((1 << params->tree_height)-1));
            () = #unspill(idx);
            idx_leaf = ((1 << XMSS_TREE_HEIGHT) - 1);
            idx_leaf &= idx;   

            // idx = idx >> params->tree_height;
            ?{}, idx = #SHR_64(idx,  XMSS_TREE_HEIGHT);
            () = #spill(idx, idx_leaf);

            // set_layer_addr(ots_addr, i);
            // set_tree_addr(ots_addr, idx);
            // set_ots_addr(ots_addr, idx_leaf);
            () = #unspill(i);
            ots_addr = __set_layer_addr(ots_addr, i);
            ots_addr = __set_tree_addr(ots_addr, idx);
            ots_addr = __set_ots_addr(ots_addr, idx_leaf);

            // // Sig_tmp = treeSig(root, SK, idx_leaf, ADRS);
            () = #unspill(sk, idx_leaf);
            sig_tmp, ots_addr = __tree_sig(sig_tmp, root, sk, idx_leaf, ots_addr);

            () = #unspill(sm_ptr);
            for j=0 to XMSS_WOTS_SIG_BYTES + (XMSS_TREE_HEIGHT * XMSS_N) {
                (u8)[sm_ptr + j] = sig_tmp[j];
            }

            sm_ptr += XMSS_WOTS_SIG_BYTES + (XMSS_TREE_HEIGHT * XMSS_N);
            () = #spill(sm_ptr);
            

            () = #unspill(i, idx_leaf);
            i += 1;
        }

        () = #unspill(sk);
    }

    ?{}, r = #set0();
    return sk, r;
}

fn _xmssmt_core_sign(
    reg ptr u8[XMSS_SK_BYTES] sk,
    reg u64 sm_ptr smlen_ptr m_ptr mlen
) -> reg ptr u8[XMSS_SK_BYTES], reg u64
{
    reg u64 r;
    sk, r = __xmssmt_core_sign(sk, sm_ptr, smlen_ptr, m_ptr, mlen);
    return sk, r;
}

inline
fn __xmssmt_core_sign_(
    reg ptr u8[XMSS_SK_BYTES] sk,
    reg u64 sm_ptr smlen_ptr m_ptr mlen
) -> reg ptr u8[XMSS_SK_BYTES], reg u64
{
    reg u64 r;

    sk = sk;
    sm_ptr = sm_ptr;
    smlen_ptr = smlen_ptr;
    m_ptr = m_ptr;
    mlen = mlen;

    sk, r = _xmssmt_core_sign(sk, sm_ptr, smlen_ptr, m_ptr, mlen);

    sk = sk;
    r = r;

    return sk, r;
}