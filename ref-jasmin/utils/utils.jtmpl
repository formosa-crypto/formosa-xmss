inline fn __ull_to_bytes<OUTLEN>(
  reg ptr u8[OUTLEN] out,
  reg u64 in
) -> reg ptr u8[OUTLEN]
{
  inline int i;

  for i=OUTLEN-1 downto -1 {
    out[i] = (8u) in;
    in >>= 8;
  }

  return out;
}//<>

inline fn __bytes_to_ull<INLEN>(reg ptr u8[INLEN] in) -> reg u64 {
  reg u64 result i t u;

  result = 0;
  i = 0;
  while (i < INLEN) {
    // retval |= ((unsigned long long)in[i]) << (8*(inlen - 1 - i));
    // 
    // t : ((unsigned long long)in[i])
    // u : (8*(inlen - 1 - i))

    t = (64u) in[i];

    u = INLEN - 1;
    u -= i;
    ?{}, u = #SHL(u, 3); // same as u *= 8

    ?{}, t = #SHL(t, u);

    result |= t;

    i += 1;
  }

  return result;
}//<>

inline fn __bytes_to_ull_ptr(reg u64 in_ptr inlen) -> reg u64 {
  reg u64 result i t u;

  result = 0;
  i = 0;
  while (i < inlen) {
    // retval |= ((unsigned long long)in[i]) << (8*(inlen - 1 - i));
    // 
    // t : ((unsigned long long)in[i])
    // u : (8*(inlen - 1 - i))

    t = (64u) (u8) [in_ptr + i];

    u = inlen;
    u -= 1;
    u -= i;
    ?{}, u = #SHL(u, 3); // same as u *= 8

    ?{}, t = #SHL(t, u);

    result |= t;

    i += 1;
  }

  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

fn _zero_address(reg ptr u32[8] addr) -> reg ptr u32[8] {
    inline int i;
    for i=0 to 8/2 { addr[u64 i] = 0; }
    return addr;
}

inline fn __zero_address(reg ptr u32[8] addr) -> reg ptr u32[8] {
    addr = addr;
    addr = _zero_address(addr);
    addr = addr;
    return addr;
}
